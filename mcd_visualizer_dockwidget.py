"""
Mandatory libraries for performing the job
"""
import os
import tempfile
import uuid
import processing
from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt
from qgis.core import QgsProject,QgsRasterLayer, QgsLineSymbol,QgsSingleBandPseudoColorRenderer,QgsStyle,Qgis, QgsVectorLayer
from osgeo import gdal, osr
from PyQt5.QtWidgets import QMessageBox, QApplication, QDialog, QDialogButtonBox, QProgressDialog
from qgis.utils import iface
from qgis.PyQt.QtGui import QColor, QIntValidator
import xarray as xr
import numpy as np
from processing.core.Processing import Processing
from .interp_config_dialog import InterpConfigDialog

# Load UI form generated by Qt Designer, generating FORM_CLASS and base class
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'mcd_visualizer_dockwidget_base.ui'))

# Define the main dock widget class for the plugin
class MCDVisualizerDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        super(MCDVisualizerDockWidget, self).__init__(parent)
        self.setupUi(self)

        self.time_raw = True #True =  Uses raw data, False = Interpolates
        self.time_step = "1 hour" #Resolution of selected interpolation

        self.alt_raw = True

        # Base path  where NETCDF and MOLA data store
        self.ruta = r"C:\MCD6.1\data"
        # Dictionary mapping human-readable era names to actual folder names
        self.lista_carpetas = {
            "Yearly Average": "clim_aveEUV",
            "Cold": "cold",
            "Warm": "warm",
            "Stormy": "strm",
            "Martian Year 24": "MY24",
            "Martian Year 25": "MY25",
            "Martian Year 26": "MY26",
            "Martian Year 27": "MY27",
            "Martian Year 28": "MY28",
            "Martian Year 29": "MY29",
            "Martian Year 30": "MY30",
            "Martian Year 31": "MY31",
            "Martian Year 32": "MY32",
            "Martian Year 33": "MY33",
            "Martian Year 34": "MY34",
            "Martian Year 35": "MY35",
        }

        self.variable_descriptions = {
            "tsurf":"Surface temperature (K)",
            "ps":"Surface pressure (Pa)",
            "co2ice":"CO₂ ice cover (kg m⁻²)",
            "fluxsurf_lw":"LW (thermal IR) radiative flux to surface (W m⁻²)",
            "fluxtop_lw":"LW (thermal IR) radiative flux to space (W m⁻²)",
            "fluxsurf_dn_sw":"SW (solar) incoming radiative flux to surface (W m⁻²)",
            "fluxsurf_dir_dn_sw":"SW (solar) direct incoming radiative flux to surface (W m⁻²)",
            "fluxsurf_up_sw":"SW (solar) reflected radiative flux from surface (W m⁻²)",
            "fluxtop_up_sw":"SW (solar) outgoing radiative flux to space (W m⁻²)",
            "fluxtop_dn_sw":"SW (solar) incoming radiative flux from space (W m⁻²)",
            "tau_pref_gcm":"Monthly mean visible dust optical depth at 610 Pa (unitless)",
            "col_h2ovapor":"Water vapor column (kg m⁻²)",
            "col_h2oice":"Water ice column (kg m⁻²)",
            "zmax":"Height of thermals in the PBL (m)",
            "hfmax":"Maximum thermals heat flux (K·m/s)",
            "wstar":"Vertical velocity scale in thermals (m/s)",
            "h2oice":"H₂O ice cover (seasonal frost) (kg m⁻²)",
            "c_co2":"CO₂ column (molecules/cm²)",
            "c_co":"CO column (molecules/cm²)",
            "c_o":"O column (molecules/cm²)",
            "c_o2":"O₂ column (molecules/cm²)",
            "c_o3":"O₃ column (molecules/cm²)",
            "c_h":"H column (molecules/cm²)",
            "c_h2":"H₂ column (molecules/cm²)",
            "c_n2":"N₂ column (molecules/cm²)",
            "c_ar":"Ar column (molecules/cm²)",
            "c_he":"He column (molecules/cm²)",
            "c_elec":"Total Electronic Content (TEC) (electrons/cm²)",
            "rho":"Atmospheric density (kg m⁻³)",
            "temp":"Atmospheric temperature (K)",
            "u":"Zonal (East–West) wind (m/s)",
            "v":"Meridional (North–South) wind (m/s)",
            "w":"Vertical (up–down) wind (m/s)",
            "vmr_h2ovapor":"Water vapor volume mixing ratio (mol/mol)",
            "vmr_h2oice":"Water ice volume mixing ratio (mol/mol)",
            "vmr_co2":"CO₂ volume mixing ratio (mol/mol)",
            "vmr_co":"CO volume mixing ratio (mol/mol)",
            "vmr_o":"O volume mixing ratio (mol/mol)",
            "vmr_o2":"O₂ volume mixing ratio (mol/mol)",
            "vmr_o3":"O₃ volume mixing ratio (mol/mol)",
            "vmr_h":"H volume mixing ratio (mol/mol)",
            "vmr_h2":"H₂ volume mixing ratio (mol/mol)",
            "vmr_n2":"N₂ volume mixing ratio (mol/mol)",
            "vmr_ar":"Ar volume mixing ratio (mol/mol)",
            "vmr_he":"He volume mixing ratio (mol/mol)",
            "vmr_elec":"Electron number density (mol/mol)",
            "dustq":"Dust mass mixing ratio (kg/kg)",
            "reffdust":"Dust effective radius (m)",
            "reffice":"Water ice effective radius (m)",
        }

        self.Combo_Epoca.clear()
        self.Combo_Epoca.addItems(list(self.lista_carpetas.keys()))
        self.Combo_Epoca.setCurrentIndex(0)
        self.cambio_epoca(self.Combo_Epoca.currentText())

        self.Combo_Epoca.currentTextChanged.connect(self.cambio_epoca)
        self.Combo_Archivo.currentTextChanged.connect(self.cambio_archivo)
        self.Combo_Variable.itemSelectionChanged.connect(self.toggle_altitude_multi)
        self.Check_Mapa.stateChanged.connect(self.toggle_map_latlon_mode)
        self.Push_Visualizar.clicked.connect(self.visualizar_variable)
        self.Push_Reset.clicked.connect(self.reset_all)
        self.Push_InterpConfig.clicked.connect(self.open_interp_config)

        self.Combo_Altitud.setEnabled(False)
        self.Combo_Altitud.setStyleSheet("QComboBox:disabled { background-color: red }")
        self.Combo_Altitud.setToolTip("Select one variable at least")

        self.Interpolate_Altitude.setEnabled(False)
        self.Interpolate_Altitude.clear()
        self.Interpolate_Altitude.setPlaceholderText("Introduce altitude (m)")
        self.Interpolate_Altitude.setValidator(QIntValidator(5, 108000, self))

        self.toggle_altitude_multi()
        self.toggle_map_latlon_mode(self.Check_Mapa.checkState())

    def open_interp_config(self):
        dlg = InterpConfigDialog(parent=self)
        if dlg.exec_() != QtWidgets.QDialog.Accepted: # We open and block the emerging window, locking the interaction. If accepted button is clicked, it jumps to refrehs. It cancels button (or closes the window) is clicked, it leaves the function
            return

        self.refresh_time_combo()

        if self.alt_raw:
            self.refresh_alt_combo()

        self.toggle_altitude_multi()

    def refresh_time_combo(self):
        times = self.ds.Time.values.astype(float)
        t_min = times.min()
        t_max = times.max()

        if self.time_raw:
            grid = times
        else:
            if self.time_step == "1 hour":
                step = 1
            elif self.time_step == "30 min":
                step = 0.5
            elif self.time_step == "15 min":
                step = 0.25
            else:
                step = 1.0

            extra = np.arange(step, t_min, step)
            main = np.arange(t_min, t_max + 1e-6, step)
            grid = np.concatenate([extra, main])

        labels = []

        for t in grid:
            h = int(t)
            m = int(round((t-h) * 60))

            if m == 60:
                t = t+1
                m = 0

            labels.append(f"{h:02d}:{m:02d}")

        self.Combo_Hora.clear()
        self.Combo_Hora.addItems(labels)

    def refresh_alt_combo(self): #Repoblate Combo_Altitud when alt_raw is true

        if not self.alt_raw:
            return

        alts = self.ds.altitude.values.astype(float)
        labels = []

        for a in alts:
            labels.append(f"{a:.4f}")

        self.Combo_Altitud.clear()
        self.Combo_Altitud.addItems(labels)

    def cambio_epoca(self, epoca):
        #Handler for when the era combo changes: populate the file list
        carpeta = self.lista_carpetas.get(epoca)

        if not carpeta:
            return #Nothing to do if no valid folder

        prev_archivo = self.Combo_Archivo.currentText() #Stores file that was previously selected
        self.Combo_Archivo.clear()

        folder = os.path.join(self.ruta, carpeta)

        try:
            archivos = sorted(f for f in os.listdir(folder) if f.endswith("_me.nc"))
        except FileNotFoundError:
            QMessageBox.warning(self, "Error", "Folder not found")
            return

        self.Combo_Archivo.addItems(archivos)

        if prev_archivo in archivos:
            self.Combo_Archivo.setCurrentText(prev_archivo)
            self.cambio_archivo(prev_archivo)
        else:
            if len(archivos) > 0:
                self.Combo_Archivo.setCurrentIndex(0)
                self.cambio_archivo(self.Combo_Archivo.currentText())

    def cambio_archivo(self, archivo_nombre):
        if not archivo_nombre:
            return

        epoca_label = self.Combo_Epoca.currentText()
        carpeta = self.lista_carpetas.get(epoca_label)
        if not carpeta:
           return

        path = os.path.join(self.ruta, carpeta, archivo_nombre)
        try:
            ds_nuevo = xr.open_dataset(path, decode_times=False)
        except Exception as e:
            QMessageBox.critical(self, "Error al abrir NetCDF", str(e))
            return

        self.ds = ds_nuevo

        prev_vars = [item.data(Qt.UserRole) for item in self.Combo_Variable.selectedItems()] #We save already selected variables for its name in "crude"
        self.Combo_Variable.clear()

        for varname in self.ds.data_vars.keys():
            data_array = self.ds[varname]
            if("latitude" in data_array.dims) and ("longitude" in data_array.dims): #I just want to have variables that contain latitude and longitude dimensions. Otherwise, none of my interest
                if varname in self.variable_descriptions:
                    label = self.variable_descriptions[varname] # I assign a "human" name to thoses varnames (e.g. temp = "Surface Temparature (K)")
                    item = QtWidgets.QListWidgetItem(label)
                else:
                    item = QtWidgets.QListWidgetItem(f"ERROR: {varname}")
                    item.setForeGround(QColor("red"))

                item.setData(Qt.UserRole, varname)
                self.Combo_Variable.addItem(item)

        for i in range(self.Combo_Variable.count()):
            itm = self.Combo_Variable.item(i)
            if itm.data(Qt.UserRole) in prev_vars:
                itm.setSelected(True)

        prev_hora = self.Combo_Hora.currentText()
        self.refresh_time_combo()

        items = []
        for i in range(self.Combo_Hora.count()):
            items.append(self.Combo_Hora.itemText(i))

        if prev_hora in items:
            self.Combo_Hora.setCurrentText(prev_hora)
        elif self.Combo_Hora.count() > 0:
            self.Combo_Hora.setCurrentIndex(0)

        prev_alt_combo = self.Combo_Altitud.currentText()
        prev_alt_manual = self.Interpolate_Altitude.text()
        self.refresh_alt_combo()

        has_alt = "altitude" in self.ds.dims

        items_a = []

        for i in range(self.Combo_Altitud.count()):
            items_a.append(self.Combo_Altitud.count())

        if prev_alt_combo in items_a:
            self.Combo_Altitud.setCurrentText(prev_alt_combo)
        else:
            self.Combo_Altitud.setCurrentIndex(0)

        if not self.alt_raw:
            self.Interpolate_Altitude.setText(prev_alt_manual)
        else:
            self.Interpolate_Altitude.clear()

        self.toggle_altitude_multi()

        prev_lat_min = self.Combo_Latitud_Min.currentText()
        prev_lat_max = self.Combo_Latitud_Max.currentText()
        prev_lon_min = self.Combo_Longitud_Min.currentText()
        prev_lon_max = self.Combo_Longitud_Max.currentText()

        lat_vals = [f"{lat:.4f}" for lat in self.ds.latitude.values]
        self.Combo_Latitud_Min.clear()
        self.Combo_Latitud_Max.clear()
        self.Combo_Latitud_Min.addItems(lat_vals)
        self.Combo_Latitud_Max.addItems(lat_vals)
        if prev_lat_min in lat_vals:
            self.Combo_Latitud_Min.setCurrentText(prev_lat_min)
        else:
            if len(lat_vals) > 0:
                self.Combo_Latitud_Min.setCurrentIndex(0)
        if prev_lat_max in lat_vals:
            self.Combo_Latitud_Max.setCurrentText(prev_lat_max)
        else:
            if len(lat_vals) > 0:
                self.Combo_Latitud_Max.setCurrentIndex(0)

        lon_vals = [f"{lon:.4f}" for lon in self.ds.longitude.values]
        self.Combo_Longitud_Min.clear()
        self.Combo_Longitud_Max.clear()
        self.Combo_Longitud_Min.addItems(lon_vals)
        self.Combo_Longitud_Max.addItems(lon_vals)
        if prev_lon_min in lon_vals:
            self.Combo_Longitud_Min.setCurrentText(prev_lon_min)
        else:
            if len(lon_vals) > 0:
                self.Combo_Longitud_Min.setCurrentIndex(0)
        if prev_lon_max in lon_vals:
            self.Combo_Longitud_Max.setCurrentText(prev_lon_max)
        else:
            if len(lon_vals) > 0:
                self.Combo_Longitud_Max.setCurrentIndex(0)

        self.toggle_altitude_multi()

    def toggle_altitude_multi(self):
        vars_marcadas = []
        for item in self.Combo_Variable.selectedItems():
            vars_marcadas.append(item.data(Qt.UserRole))

        if not vars_marcadas:
            self.Combo_Altitud.setEnabled(False)
            self.Combo_Altitud.setStyleSheet("QComboBox:disabled { background-color: red }")
            self.Combo_Altitud.setToolTip("Select one variable at least")
            self.Interpolate_Altitude.setEnabled(False)
            return

        for var in vars_marcadas:
            if var in self.ds.data_vars and "altitude" in self.ds[var].dims:
                if self.alt_raw:
                    self.Combo_Altitud.setEnabled(True)
                    self.Combo_Altitud.setStyleSheet("")
                    self.Combo_Altitud.setToolTip("")
                    self.Interpolate_Altitude.setEnabled(False)
                else:
                    self.Combo_Altitud.setEnabled(False)
                    self.Combo_Altitud.setStyleSheet("QComboBox:disabled { background-color: red }")
                    self.Combo_Altitud.setToolTip("Manual mode selected")
                    self.Interpolate_Altitude.setEnabled(True)
                return

        self.Combo_Altitud.setEnabled(False)
        self.Combo_Altitud.setStyleSheet("QComboBox:disabled { background-color: red }")
        self.Combo_Altitud.setToolTip("No variable selected contains 'altitude' dimension")
        self.Interpolate_Altitude.setEnabled(False)

    def toggle_map_latlon_mode(self, estado):

        checked = (estado != 0)

        combos = [self.Combo_Latitud_Min, self.Combo_Latitud_Max, self.Combo_Longitud_Min, self.Combo_Longitud_Max]

        if checked:
            for combo in combos:
                combo.setEnabled(False)
                combo.setStyleSheet("QComboBox { background-color: red; }")
                combo.setToolTip("Latitude/Longitude Selector is disabled when full map is selected")
        else:
            for combo in combos:
                combo.setEnabled(True)
                combo.setStyleSheet("")

    def reset_all(self):
        self.Combo_Epoca.setCurrentIndex(0)

        if self.Combo_Archivo.count() > 0:
            self.Combo_Archivo.setCurrentIndex(0)

        if self.Combo_Variable.count() > 0:
            for i in range(self.Combo_Variable.count()):
                self.Combo_Variable.item(i).setSelected(False)

        if self.Combo_Hora.count() > 0:
            self.Combo_Hora.setCurrentIndex(0)

        self.time_raw = True
        self.time_step = "1 hour"
        self.refresh_time_combo()

        self.alt_raw = True

        self.refresh_alt_combo()
        if self.Combo_Altitud.count() > 0:
            self.Combo_Altitud.setCurrentIndex(0)

        self.Interpolate_Altitude.clear()
        self.toggle_altitude_multi()

        if self.Combo_Latitud_Min.count() > 0:
            self.Combo_Latitud_Min.setCurrentIndex(0)
        if self.Combo_Latitud_Max.count() > 0:
            self.Combo_Latitud_Max.setCurrentIndex(0)
        if self.Combo_Longitud_Min.count() > 0:
            self.Combo_Longitud_Min.setCurrentIndex(0)
        if self.Combo_Longitud_Max.count() > 0:
            self.Combo_Longitud_Max.setCurrentIndex(0)

        if self.Check_Mapa.isChecked():
            self.Check_Mapa.setChecked(False)

    def visualizar_variable(self):
        #Main handler for visualizing the selected variable
        #Read numeric lat/lon from combos
        lat_min = float(self.Combo_Latitud_Min.currentText())
        lat_max = float(self.Combo_Latitud_Max.currentText())
        lon_min = float(self.Combo_Longitud_Min.currentText())
        lon_max = float(self.Combo_Longitud_Max.currentText())

        #Validate ranges if not showing full map
        if not self.Check_Mapa.isChecked():
            if lat_min >= lat_max:
                QMessageBox.warning(self, "Invalid latitude range",
                                    "Min latitude must be lower than max latitude")
                return
            if lon_min >= lon_max:
                QMessageBox.warning(self, "Invalid longitude range",
                                    "Min longitude must be lower than max longitude")
                return

        vars_sel = [item.data(Qt.UserRole) for item in self.Combo_Variable.selectedItems()]

        if not vars_sel:
            QMessageBox.warning(self, "No variables", "You must select at least one variable")
            return

        dlg = QProgressDialog("Generating raster layers...", None, 0, len(vars_sel), self)
        dlg.setWindowModality(Qt.WindowModal)
        dlg.setCancelButton(None)
        dlg.setMinimumDuration(0)
        dlg.setWindowTitle("Please, wait")
        dlg.show()

        try:
            for idx, varname in enumerate(vars_sel):
                da = self.ds[varname]

                if "Time" in da.dims:
                    if self.time_raw:
                        da = da.isel(Time = self.Combo_Hora.currentIndex())
                    else:
                        time_str = self.Combo_Hora.currentText()
                        h, m = map(int, time_str.split(":"))
                        user_time = h + m/60.0

                        t_min = float(self.ds.Time.values.min())
                        t_max = float(self.ds.Time.values.max())

                        if user_time >= t_min:
                            da = da.interp(Time = user_time, method = "linear") #normal interp [t_min, t_max]
                        else:
                            frac = user_time/t_min
                            v_low = da.sel(Time = t_max)
                            v_high = da.sel(Time = t_min)
                            da = v_low*(1-frac) + v_high*frac

                if "altitude" in da.dims:
                    if self.alt_raw:
                        da = da.isel(altitude = self.Combo_Altitud.currentIndex())
                    else:
                        text = self.Interpolate_Altitude.text()
                        if not text:
                            QMessageBox.warning(self, "Altitude", "Introduce altitude value in m")
                            return

                        user_alt_km = float(text) / 1000.0
                        da = da.interp(altitude = user_alt_km, method = "linear")


                if not self.Check_Mapa.isChecked():
                    lat_vals = self.ds.latitude.values
                    if lat_vals[0] < lat_vals[-1]:
                        lat_slice = slice(lat_min, lat_max)
                    else:
                        lat_slice = slice(lat_max, lat_min)

                    lon_vals = self.ds.longitude.values
                    if lon_vals[0] < lon_vals[-1]:
                        lon_slice = slice(lon_min, lon_max)
                    else:
                        lon_slice = slice(lon_max, lon_min)

                    da = da.sel(latitude = lat_slice, longitude = lon_slice)

                lats = da.latitude.values
                lons = da.longitude.values
                array = da.values

                if array.size == 0:
                    QMessageBox.warning(self, "No data", f"Variable {self.variable_descriptions[varname]} has no data in the lat/lon cut.")
                    dlg.setValue(idx + 1)
                    QApplication.processEvents()
                    continue

                display_name = self.variable_descriptions[varname]
                self._mostrar_raster(array, lats, lons, varname, display_name)

                dlg.setValue(idx + 1)
                QApplication.processEvents()

            self.loadMolaBase()

        finally:
            dlg.close()

    def loadMolaBase(self):
        #Handler to load or reload the MOLA contour layer
        Processing.initialize()

        # Remove previous MOLA layer if presented by ID
        prev_id = getattr(self, 'mola_layer_id', None)
        if prev_id:
            lyr = QgsProject.instance().mapLayer(prev_id)
            if lyr:
                QgsProject.instance().removeMapLayer(prev_id)
            self.mola_layer_id = None
            self.mola_loaded = False

        #Path to original MOLA GeoTIFF
        plugin_dir = os.path.dirname(__file__)
        origen = os.path.join(plugin_dir, "mola32_isolines.tif")
        #Spatial crop if full map not checked on GUI
        if not self.Check_Mapa.isChecked():
            lon_min = float(self.Combo_Longitud_Min.currentText())
            lon_max = float(self.Combo_Longitud_Max.currentText())
            lat_min = float(self.Combo_Latitud_Min.currentText())
            lat_max = float(self.Combo_Latitud_Max.currentText())
            opts = gdal.TranslateOptions(
                format="GTiff",
                projWin=[lon_min, lat_max, lon_max, lat_min]
            )
            tmp_tif = os.path.join(tempfile.gettempdir(), "mola_crop.tif")
            gdal.Translate(tmp_tif, origen, options=opts)
            raster_path = tmp_tif
        else:
            raster_path = origen

        # Downsample by factor 4 to speed up contour generation
        ds = gdal.Open(raster_path)
        gt = ds.GetGeoTransform()
        down_tif = os.path.join(tempfile.gettempdir(), "mola_down.tif")
        gdal.Warp(
            down_tif, ds,
            xRes=gt[1] * 4,
            yRes=abs(gt[5]) * 4,
            resampleAlg='bilinear'
        )
        ds = None
        raster_path = down_tif

        # 3) Create unique shpapefile for contours
        shp_path = os.path.join(tempfile.gettempdir(), f"mola_contours_{uuid.uuid4().hex}.shp")
        # Clean lefotvers
        for ext in ("shp", "shx", "dbf", "prj"):
            try:
                os.remove(shp_path[:-3] + ext)
            except OSError:
                pass

        # Run GDAL contour algorithm to generate vector contours every 1000m
        params = {
            'INPUT': raster_path,
            'BAND': 1,
            'INTERVAL': 1000.0,
            'FIELD_NAME': 'ELEV',
            'OUTPUT': shp_path
        }
        result = processing.run("gdal:contour", params)
        if 'OUTPUT' not in result or not result['OUTPUT']:
            QMessageBox.critical(self, "Error", "gdal:contour falló sin salida.")
            return

        # Load resulting shapefile as a vector layer
        cont_layer = QgsVectorLayer(result['OUTPUT'], "MOLA Isolines", "ogr")
        if not cont_layer.isValid():
            QMessageBox.critical(self, "Error", "No se pudieron cargar las isolíneas de MOLA.")
            return

        # Put image thickness up to 0.2mm
        sym = cont_layer.renderer().symbol()
        sym.setColor(QColor(0, 0, 0)) #Set line color to black
        sym.setWidth(0.2) #Set line width to 0.2mm
        cont_layer.triggerRepaint()

        #Add layer with default ordering so it appears on top
        root = QgsProject.instance().layerTreeRoot()
        QgsProject.instance().addMapLayer(cont_layer, addToLegend=False)
        root.insertLayer(0, cont_layer)

        #Save ID for future removal
        self.mola_layer_id = cont_layer.id()
        self.mola_loaded = True

    def _mostrar_raster(self, array, lat, lon, safe_name, layer_name):
        arr = np.asarray(array) #Internal method to display a numpy array as a QGIS raster layer

        #Check that data array is non-empty
        if arr.size == 0 or len(lat) == 0 or len(lon) == 0:
            QMessageBox.warning(
                self,
                "No data",
                "Selected crop has no info"
            )
            return

        # Ensure data to be displyed is 2D
        if arr.ndim != 2:
            QMessageBox.warning(self, "ERROR", "Raster is not a 2D Filaye. Cannot be desplayed")
            return

        #Flip vertically for correct georeferencing
        arr = np.flipud(arr)

        #Create temporary GeoTIFF file
        temp_dir = tempfile.gettempdir()
        filename = f"{safe_name}_{uuid.uuid4().hex}.tif"
        path = os.path.join(temp_dir, filename)

        #Create geotransform parameters
        nrows, ncols = arr.shape
        xres = (lon[-1] - lon[0]) / ncols
        yres = (lat[-1] - lat[0]) / nrows

        drv = gdal.GetDriverByName("GTiff")
        ds = drv.Create(path, ncols, nrows, 1, gdal.GDT_Float32)
        ds.SetGeoTransform((lon[0], xres, 0, lat[-1], 0, -yres))
        srs = osr.SpatialReference()
        srs.ImportFromEPSG(4326)
        ds.SetProjection(srs.ExportToWkt())
        ds.GetRasterBand(1).WriteArray(arr)
        ds.FlushCache()
        ds = None

        #Load Geo TIFF as a QGIS Raster Layer
        layer = QgsRasterLayer(path, layer_name)
        if not layer.isValid():
            QMessageBox.critical(self, "Error", "No se pudo cargar el raster.")
            return

        #Apply pseudo-color renderer using turbo-ramp
        provider = layer.dataProvider()
        ramp = QgsStyle().defaultStyle().colorRamp('Turbo')
        renderer = QgsSingleBandPseudoColorRenderer(provider, 1)
        renderer.createShader(
            ramp,
            Qgis.ShaderInterpolationMethod.Linear,
            Qgis.ShaderClassificationMethod.Continuous,
            0
        )
        layer.setRenderer(renderer)
        layer.setOpacity(0.8) #Layer opacity up to 80%

        #Add layer to the project
        QgsProject.instance().addMapLayer(layer)
        layer.triggerRepaint()

        #Automatically applpy symology changes by simulating Apply click
        iface.showLayerProperties(layer, 'symbology')
        for w in QApplication.topLevelWidgets():
            if isinstance(w, QDialog) and w.windowTitle().startswith("Propiedades de capa"):
                w.close()
        iface.showLayerProperties(layer, 'symbology')
        for w in QApplication.topLevelWidgets():
            if isinstance(w, QDialog) and w.windowTitle().startswith("Propiedades de capa"):
                for bb in w.findChildren(QDialogButtonBox):
                    btn_apply = bb.button(QDialogButtonBox.Apply)
                    if btn_apply:
                        btn_apply.click()
                        w.close()
                break

    def closeEvent(self, event):
        #Emit signal and accept close event when plugin is closed
        self.closingPlugin.emit()
        event.accept()