"""
Mandatory libraries for performing the job
"""
import os
import tempfile
import uuid
import processing
from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt
from qgis.core import QgsProject,QgsRasterLayer,QgsRasterContourRenderer,QgsLineSymbol,QgsSingleBandPseudoColorRenderer,QgsStyle,Qgis, QgsVectorLayer
from osgeo import gdal, osr
from PyQt5.QtWidgets import QMessageBox, QApplication, QDialog, QDialogButtonBox, QProgressDialog
from qgis.utils import iface
from qgis.PyQt.QtGui import QColor
import xarray as xr
import numpy as np

# Load UI form generated by Qt Designer, generating FORM_CLASS and base class
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'mcd_visualizer_dockwidget_base.ui'))

# Define the main dock widget class for the plugin
class MCDVisualizerDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        super(MCDVisualizerDockWidget, self).__init__(parent)
        self.setupUi(self)

        # Base path  where NETCDF and MOLA data store (To be changed soon)
        self.ruta = r"C:\MCD6.1\data"
        # Dictionary mapping human-readable era names to actual folder names
        self.lista_carpetas = {
            "Promedio Anual": "clim_aveEUV",
            "Frio": "cold",
            "Templado": "warm",
            "Tormentoso": "strm",
            "Año Marciano 24": "MY24",
            "Año Marciano 25": "MY25",
            "Año Marciano 26": "MY26",
            "Año Marciano 27": "MY27",
            "Año Marciano 28": "MY28",
            "Año Marciano 29": "MY29",
            "Año Marciano 30": "MY30",
            "Año Marciano 31": "MY31",
            "Año Marciano 32": "MY32",
            "Año Marciano 33": "MY33",
            "Año Marciano 34": "MY34",
            "Año Marciano 35": "MY35",
        }

        #Connect Combo_Box signals to their respective handlers
        self.Combo_Archivo.currentTextChanged.connect(self.cambio_archivo)
        self.Combo_Epoca.currentTextChanged.connect(self.cambio_epoca)
        self.Combo_Variable.currentTextChanged.connect(self.toggle_altitude)

        #Flag to track if MOLA layer is loaded (Currently unused)
        self.mola_loaded = False

        #Connect the visualize button to the visualization handler
        self.Push_Visualizar.clicked.connect(self.visualizar_variable)

        #Initialize Combo_Boxes based on the default selection
        self.cambio_epoca(self.Combo_Epoca.currentText())
        self.toggle_altitude(self.Combo_Variable.currentText())

    def cambio_epoca(self, epoca):
        #Handler for when the era combo changes: populate the file list
        carpeta = self.lista_carpetas.get(epoca)
        self.Combo_Archivo.clear() #Clear existing items
        if not carpeta:
            return #Nothing to do if no valid folder
        folder = os.path.join(self.ruta, carpeta)
        try:
            archivos = sorted(f for f in os.listdir(folder) if f.endswith("_me.nc")) #List all files ending with "_me.nc"
        except FileNotFoundError:
            QMessageBox.warning(self, "Error", "No existe dicha carpeta")
            return
        self.Combo_Archivo.addItems(archivos)

    def cambio_archivo(self, archivo_nombre):
        #Handler for when the file combo changes: Load the dataset and populate other combos
        if not archivo_nombre:
            return
        epoca_label = self.Combo_Epoca.currentText()
        carpeta = self.lista_carpetas[epoca_label]
        path = os.path.join(self.ruta, carpeta, archivo_nombre)
        try:
            #Open NetCDF file without decoding time coordinates. Catastrophic fail if not done
            self.ds = xr.open_dataset(path, decode_times=False)
        except Exception as e:
            QMessageBox.critical(self, "Error al abrir el archivo NetCDF", str(e))
            return

        # Populate variable combo with data variable names
        self.Combo_Variable.clear()
        self.Combo_Variable.addItems(list(self.ds.data_vars.keys()))

        # Populate time combo with integer values of Time dimension
        self.Combo_Hora.clear()
        self.Combo_Hora.addItems([str(int(t)) for t in self.ds.Time.values])

        # Populate altitude combo with altitude values formatted to 4 decimal places
        self.Combo_Altitud.clear()
        self.Combo_Altitud.addItems([f"{a:.4f}" for a in self.ds.altitude.values])

        # Populate latitude/longitude min/max combos with coordinates values
        self.Combo_Latitud_Min.clear()
        self.Combo_Latitud_Max.clear()
        self.Combo_Longitud_Min.clear()
        self.Combo_Longitud_Max.clear()
        self.Combo_Latitud_Min.addItems([f"{lat:.4f}" for lat in self.ds.latitude.values])
        self.Combo_Latitud_Max.addItems([f"{lat:.4f}" for lat in self.ds.latitude.values])
        self.Combo_Longitud_Min.addItems([f"{lon:.4f}" for lon in self.ds.longitude.values])
        self.Combo_Longitud_Max.addItems([f"{lon:.4f}" for lon in self.ds.longitude.values])

        #Toggle altitude combo based on selected variable
        self.toggle_altitude(self.Combo_Variable.currentText())

    def toggle_altitude(self, var_name):
        # Enable or disable altitude combo based on presence of altitude dimension
        if hasattr(self, 'ds') and var_name in self.ds.data_vars:
            da = self.ds[var_name]
            if "altitude" in da.dims:
                self.Combo_Altitud.setEnabled(True)
                return
        # disable and style the combo red if no altitude dimension
        self.Combo_Altitud.setEnabled(False)
        self.Combo_Altitud.setStyleSheet("QComboBox:disabled { background-color: red }")
        self.Combo_Altitud.setToolTip("Esta variable no tiene dimensión 'altitude'")

    def visualizar_variable(self):
        #Main handler for visualizing the selected variable
        #Read numeric lat/lon from combos
        lat_min = float(self.Combo_Latitud_Min.currentText())
        lat_max = float(self.Combo_Latitud_Max.currentText())
        lon_min = float(self.Combo_Longitud_Min.currentText())
        lon_max = float(self.Combo_Longitud_Max.currentText())

        #Validate ranges if not showing full map
        if not self.Check_Mapa.isChecked():
            if lat_min >= lat_max:
                QMessageBox.warning(self, "Rango de latitudes inválido",
                                    "La latitud mínima debe ser menor que la máxima.")
                return
            if lon_min >= lon_max:
                QMessageBox.warning(self, "Rango de longitudes inválido",
                                    "La longitud mínima debe ser menor que la máxima.")
                return

        #Extract DataArray for selected variable
        da = self.ds[self.Combo_Variable.currentText()]

        #Selec time index if Time Dimension
        if "Time" in da.dims:
            da = da.isel(Time=self.Combo_Hora.currentIndex())
        # Select altitude index if altitude dimension enabled
        if "altitude" in da.dims and self.Combo_Altitud.isEnabled():
            da = da.isel(altitude=self.Combo_Altitud.currentIndex())

        #Spacial slice if not full map
        if not self.Check_Mapa.isChecked():
            lat_vals = self.ds.latitude.values
            #Determine correct slice based on coordinate order
            if lat_vals[0] < lat_vals[-1]:
                lat_slice = slice(lat_min, lat_max)
            else:
                lat_slice = slice(lat_max, lat_min)

            lon_vals = self.ds.longitude.values
            if lon_vals[0] < lon_vals[-1]:
                lon_slice = slice(lon_min, lon_max)
            else:
                lon_slice = slice(lon_max, lon_min)

            #Apply .sel for labeled slicing
            da = da.sel(latitude=lat_slice, longitude=lon_slice)

        # Extract sliced coordinates and values
        lats = da.latitude.values
        lons = da.longitude.values
        array = da.values

        #Warn if no data (empty data array)
        if array.size == 0:
            QMessageBox.warning(self, "Sin datos","El recorte seleccionado no contiene datos.")
            return

        # Show progress bar while mola and map are being generated
        dlg = QProgressDialog("Processing Files…", None, 0, 0, self)
        dlg.setWindowModality(Qt.WindowModal)
        dlg.setCancelButton(None)  # sin botón cancelar
        dlg.setMinimumDuration(0)  # aparece de inmediato
        dlg.setWindowTitle("Please, wait")
        dlg.show()
        QApplication.processEvents()  # para que se dibuje

        try:
            #Display the raster
            self._mostrar_raster(array, lats, lons, self.Combo_Variable.currentText())
            #Load mola contours on top
            self.loadMolaBase()
        finally:
            #Close progress bar when images are ploted
            dlg.close()

    def loadMolaBase(self):
        #Handler to load or reload the MOLA contour layer
        from processing.core.Processing import Processing
        Processing.initialize()

        # Remove previous MOLA layer if presented by ID
        prev_id = getattr(self, 'mola_layer_id', None)
        if prev_id:
            lyr = QgsProject.instance().mapLayer(prev_id)
            if lyr:
                QgsProject.instance().removeMapLayer(prev_id)
            self.mola_layer_id = None
            self.mola_loaded = False

        #Path to original MOLA GeoTIFF
        plugin_dir = os.path.dirname(__file__)
        origen = os.path.join(plugin_dir, "mola32_isolines.tif")
        #Spatial crop if full map not checked on GUI
        if not self.Check_Mapa.isChecked():
            lon_min = float(self.Combo_Longitud_Min.currentText())
            lon_max = float(self.Combo_Longitud_Max.currentText())
            lat_min = float(self.Combo_Latitud_Min.currentText())
            lat_max = float(self.Combo_Latitud_Max.currentText())
            opts = gdal.TranslateOptions(
                format="GTiff",
                projWin=[lon_min, lat_max, lon_max, lat_min]
            )
            tmp_tif = os.path.join(tempfile.gettempdir(), "mola_crop.tif")
            gdal.Translate(tmp_tif, origen, options=opts)
            raster_path = tmp_tif
        else:
            raster_path = origen

        # Downsample by factor 4 to speed up contour generation
        ds = gdal.Open(raster_path)
        gt = ds.GetGeoTransform()
        down_tif = os.path.join(tempfile.gettempdir(), "mola_down.tif")
        gdal.Warp(
            down_tif, ds,
            xRes=gt[1] * 4,
            yRes=abs(gt[5]) * 4,
            resampleAlg='bilinear'
        )
        ds = None
        raster_path = down_tif

        # 3) Create unique shpapefile for contours
        shp_path = os.path.join(tempfile.gettempdir(), f"mola_contours_{uuid.uuid4().hex}.shp")
        # Clean lefotvers
        for ext in ("shp", "shx", "dbf", "prj"):
            try:
                os.remove(shp_path[:-3] + ext)
            except OSError:
                pass

        # Run GDAL contour algorithm to generate vector contours every 1000m
        params = {
            'INPUT': raster_path,
            'BAND': 1,
            'INTERVAL': 1000.0,
            'FIELD_NAME': 'ELEV',
            'OUTPUT': shp_path
        }
        result = processing.run("gdal:contour", params)
        if 'OUTPUT' not in result or not result['OUTPUT']:
            QMessageBox.critical(self, "Error", "gdal:contour falló sin salida.")
            return

        # Load resulting shapefile as a vector layer
        cont_layer = QgsVectorLayer(result['OUTPUT'], "MOLA curvas 1000 m", "ogr")
        if not cont_layer.isValid():
            QMessageBox.critical(self, "Error", "No se pudieron cargar las isolíneas de MOLA.")
            return

        # Put image thickness up to 0.2mm
        sym = cont_layer.renderer().symbol()
        sym.setColor(QColor(0, 0, 0)) #Set line color to black
        sym.setWidth(0.2) #Set line width to 0.2mm
        cont_layer.triggerRepaint()

        #Add layer with default ordering so it appears on top
        root = QgsProject.instance().layerTreeRoot()
        QgsProject.instance().addMapLayer(cont_layer, addToLegend=False)
        root.insertLayer(0, cont_layer)

        #Save ID for future removal
        self.mola_layer_id = cont_layer.id()
        self.mola_loaded = True

    def _mostrar_raster(self, array, lat, lon, nombre):
        arr = np.asarray(array) #Internal method to display a numpy array as a QGIS raster layer

        #Check that data array is non-empty
        if arr.size == 0 or len(lat) == 0 or len(lon) == 0:
            QMessageBox.warning(
                self,
                "No data",
                "Selected crop has no info"
            )
            return

        # Ensure data to be displyed is 2D
        if arr.ndim != 2:
            QMessageBox.warning(self, "ERROR", "Raster is not a 2D Filaye. Cannot be desplayed")
            return

        #Flip vertically for correct georeferencing
        arr = np.flipud(arr)

        #Create temporary GeoTIFF file
        temp_dir = tempfile.gettempdir()
        filename = f"{nombre}_{uuid.uuid4().hex}.tif"
        path = os.path.join(temp_dir, filename)

        #Create geotransform parameters
        nrows, ncols = arr.shape
        xres = (lon[-1] - lon[0]) / ncols
        yres = (lat[-1] - lat[0]) / nrows

        drv = gdal.GetDriverByName("GTiff")
        ds = drv.Create(path, ncols, nrows, 1, gdal.GDT_Float32)
        ds.SetGeoTransform((lon[0], xres, 0, lat[-1], 0, -yres))
        srs = osr.SpatialReference()
        srs.ImportFromEPSG(4326)
        ds.SetProjection(srs.ExportToWkt())
        ds.GetRasterBand(1).WriteArray(arr)
        ds.FlushCache()
        ds = None

        #Load Geo TIFF as a QGIS Raster Layer
        layer = QgsRasterLayer(path, nombre)
        if not layer.isValid():
            QMessageBox.critical(self, "Error", "No se pudo cargar el raster.")
            return

        #Apply pseudo-color renderer using turbo-ramp
        provider = layer.dataProvider()
        ramp = QgsStyle().defaultStyle().colorRamp('Turbo')
        renderer = QgsSingleBandPseudoColorRenderer(provider, 1)
        renderer.createShader(
            ramp,
            Qgis.ShaderInterpolationMethod.Linear,
            Qgis.ShaderClassificationMethod.Continuous,
            0
        )
        layer.setRenderer(renderer)
        layer.setOpacity(0.8) #Layer opacity up to 80%

        #Add layer to the project
        QgsProject.instance().addMapLayer(layer)
        layer.triggerRepaint()

        #Automatically applpy symology changes by simulating Apply click
        iface.showLayerProperties(layer, 'symbology')
        for w in QApplication.topLevelWidgets():
            if isinstance(w, QDialog) and w.windowTitle().startswith("Propiedades de capa"):
                w.close()
        iface.showLayerProperties(layer, 'symbology')
        for w in QApplication.topLevelWidgets():
            if isinstance(w, QDialog) and w.windowTitle().startswith("Propiedades de capa"):
                for bb in w.findChildren(QDialogButtonBox):
                    btn_apply = bb.button(QDialogButtonBox.Apply)
                    if btn_apply:
                        btn_apply.click()
                        w.close()
                break

    def closeEvent(self, event):
        #Emit signal and accept close event when plugin is closed
        self.closingPlugin.emit()
        event.accept()