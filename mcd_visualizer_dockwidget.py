"""
Mandatory libraries for performing the job
"""
import os
import tempfile
import uuid
import processing
import matplotlib.pyplot as plt
from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt
from qgis.core import QgsProject,QgsRasterLayer, QgsLineSymbol,QgsSingleBandPseudoColorRenderer,QgsStyle,Qgis, QgsVectorLayer
from osgeo import gdal, osr
from PyQt5.QtWidgets import QMessageBox, QApplication, QDialog, QDialogButtonBox, QProgressDialog, QScrollArea, QSizePolicy
from qgis.utils import iface
from qgis.PyQt.QtGui import QColor, QIntValidator
import xarray as xr
import numpy as np
from processing.core.Processing import Processing
from .interp_config_dialog import InterpConfigDialog
from .interp_config_dialog_profile import InterpConfigDialogProfile


# Load UI form generated by Qt Designer, generating FORM_CLASS and base class
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'mcd_visualizer_dockwidget_base_profiles.ui'))

# Define the main dock widget class for the plugin
class MCDVisualizerDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        super(MCDVisualizerDockWidget, self).__init__(parent)
        self.setupUi(self)

        self.time_raw = True #True =  Uses raw data, False = Interpolates
        self.time_step = "1 hour" #Resolution of selected interpolation

        self.alt_raw = True

        self.lat_raw = True
        self.lat_step = "2"

        self.lon_raw = True
        self.lon_step = "2"

        self.time_raw_profile = True #True =  Uses raw data, False = Interpolates
        self.time_step_profile = "1 hour" #Resolution of selected interpolation

        self.alt_raw_profile = True

        self.lat_raw_profile = True
        self.lat_step_profile = "2"

        self.lon_raw_profile = True
        self.lon_step_profile = "2"

        # Base path  where NETCDF and MOLA data store
        self.ruta = r"C:\MCD6.1\data"
        # Dictionary mapping human-readable era names to actual folder names
        self.lista_carpetas = {
            "Yearly Average": "clim_aveEUV",
            "Cold": "cold",
            "Warm": "warm",
            "Stormy": "strm",
            "Martian Year 24": "MY24",
            "Martian Year 25": "MY25",
            "Martian Year 26": "MY26",
            "Martian Year 27": "MY27",
            "Martian Year 28": "MY28",
            "Martian Year 29": "MY29",
            "Martian Year 30": "MY30",
            "Martian Year 31": "MY31",
            "Martian Year 32": "MY32",
            "Martian Year 33": "MY33",
            "Martian Year 34": "MY34",
            "Martian Year 35": "MY35",
        }

        self.variable_descriptions = {
            "tsurf":"Surface temperature (K)",
            "ps":"Surface pressure (Pa)",
            "co2ice":"CO₂ ice cover (kg m⁻²)",
            "fluxsurf_lw":"LW (thermal IR) radiative flux to surface (W m⁻²)",
            "fluxtop_lw":"LW (thermal IR) radiative flux to space (W m⁻²)",
            "fluxsurf_dn_sw":"SW (solar) incoming radiative flux to surface (W m⁻²)",
            "fluxsurf_dir_dn_sw":"SW (solar) direct incoming radiative flux to surface (W m⁻²)",
            "fluxsurf_up_sw":"SW (solar) reflected radiative flux from surface (W m⁻²)",
            "fluxtop_up_sw":"SW (solar) outgoing radiative flux to space (W m⁻²)",
            "fluxtop_dn_sw":"SW (solar) incoming radiative flux from space (W m⁻²)",
            "tau_pref_gcm":"Monthly mean visible dust optical depth at 610 Pa (unitless)",
            "col_h2ovapor":"Water vapor column (kg m⁻²)",
            "col_h2oice":"Water ice column (kg m⁻²)",
            "zmax":"Height of thermals in the PBL (m)",
            "hfmax":"Maximum thermals heat flux (K·m/s)",
            "wstar":"Vertical velocity scale in thermals (m/s)",
            "h2oice":"H₂O ice cover (seasonal frost) (kg m⁻²)",
            "c_co2":"CO₂ column (molecules/cm²)",
            "c_co":"CO column (molecules/cm²)",
            "c_o":"O column (molecules/cm²)",
            "c_o2":"O₂ column (molecules/cm²)",
            "c_o3":"O₃ column (molecules/cm²)",
            "c_h":"H column (molecules/cm²)",
            "c_h2":"H₂ column (molecules/cm²)",
            "c_n2":"N₂ column (molecules/cm²)",
            "c_ar":"Ar column (molecules/cm²)",
            "c_he":"He column (molecules/cm²)",
            "c_elec":"Total Electronic Content (TEC) (electrons/cm²)",
            "rho":"Atmospheric density (kg m⁻³)",
            "temp":"Atmospheric temperature (K)",
            "u":"Zonal (East–West) wind (m/s)",
            "v":"Meridional (North–South) wind (m/s)",
            "w":"Vertical (up–down) wind (m/s)",
            "vmr_h2ovapor":"Water vapor volume mixing ratio (mol/mol)",
            "vmr_h2oice":"Water ice volume mixing ratio (mol/mol)",
            "vmr_co2":"CO₂ volume mixing ratio (mol/mol)",
            "vmr_co":"CO volume mixing ratio (mol/mol)",
            "vmr_o":"O volume mixing ratio (mol/mol)",
            "vmr_o2":"O₂ volume mixing ratio (mol/mol)",
            "vmr_o3":"O₃ volume mixing ratio (mol/mol)",
            "vmr_h":"H volume mixing ratio (mol/mol)",
            "vmr_h2":"H₂ volume mixing ratio (mol/mol)",
            "vmr_n2":"N₂ volume mixing ratio (mol/mol)",
            "vmr_ar":"Ar volume mixing ratio (mol/mol)",
            "vmr_he":"He volume mixing ratio (mol/mol)",
            "vmr_elec":"Electron number density (mol/mol)",
            "dustq":"Dust mass mixing ratio (kg/kg)",
            "reffdust":"Dust effective radius (m)",
            "reffice":"Water ice effective radius (m)",
        }

        self.Combo_Epoca.clear()
        self.Combo_Epoca.addItems(list(self.lista_carpetas.keys()))
        self.Combo_Epoca.setCurrentIndex(0)
        self.cambio_epoca(self.Combo_Epoca.currentText())

        self.Combo_Epoca.currentTextChanged.connect(self.cambio_epoca)
        self.Combo_Archivo.currentTextChanged.connect(self.cambio_archivo)
        self.Combo_Variable.itemSelectionChanged.connect(self.toggle_altitude_multi)
        self.Check_Mapa.stateChanged.connect(self.toggle_map_latlon_mode)
        self.Push_Visualizar.clicked.connect(self.visualizar_variable)
        self.Push_Reset.clicked.connect(self.reset_all)
        self.Push_InterpConfig.clicked.connect(self.open_interp_config)

        self.Combo_Altitud.setEnabled(False)
        self.Combo_Altitud.setStyleSheet("QComboBox:disabled { background-color: red }")
        self.Combo_Altitud.setToolTip("Select one variable at least")

        self.Interpolate_Altitude.setEnabled(False)
        self.Interpolate_Altitude.clear()
        self.Interpolate_Altitude.setPlaceholderText("Introduce altitude (m)")

        self.toggle_altitude_multi()
        self.toggle_map_latlon_mode(self.Check_Mapa.checkState())

        #PROFILE INIT

        self.Combo_Epoca_Profile.clear()
        self.Combo_Epoca_Profile.addItems(list(self.lista_carpetas.keys()))
        self.Combo_Epoca_Profile.setCurrentIndex(0)
        self.Combo_Epoca_Profile.currentTextChanged.connect(self.cambio_epoca_profile)
        self.Combo_Archivo_Profile.currentTextChanged.connect(self.cambio_archivo_profile)

        self.cambio_epoca_profile(self.Combo_Epoca_Profile.currentText())

        self.Combo_Profile_X.currentIndexChanged.connect(self.on_profile_axes_changed)
        self.Combo_Profile_Y.currentIndexChanged.connect(self.on_profile_axes_changed)
        self.Combo_Variable_Profile.itemSelectionChanged.connect(self.on_profile_axes_changed)

        self.Push_Reset_Profile.clicked.connect(self.reset_all_profile)

        self.Push_Visualizar_Profile.clicked.connect(self.visualize_variable_profile)

        self.on_profile_axes_changed()

        self.Push_InterpConfig_Profile.clicked.connect(self.open_interp_config_profile)

        self.Interpolate_Altitude_Profile.setEnabled(False)
        self.Interpolate_Altitude_Profile.clear()
        self.Interpolate_Altitude_Profile.setPlaceholderText("Introduce altitude (m)")

    def open_interp_config(self):
        prev_time_raw = self.time_raw
        prev_time_step = self.time_step
        prev_alt_raw = self.alt_raw
        prev_lat_raw = self.lat_raw
        prev_lat_step = self.lat_step
        prev_lon_raw = self.lon_raw
        prev_lon_step = self.lon_step

        dlg = InterpConfigDialog(parent=self)
        if dlg.exec_() != QtWidgets.QDialog.Accepted:
            return

        self.time_raw  = (dlg.Combo_Time_Mode.currentText() == "Raw data")
        self.time_step = dlg.Combo_Time_Resolution.currentText()

        self.alt_raw = (dlg.Combo_Altitude_Mode.currentText() == "Raw data")

        self.lat_raw  = (dlg.Combo_Latitude_Mode.currentText() == "Raw data")
        self.lat_step = dlg.Combo_Latitude_Resolution.currentText()

        self.lon_raw  = (dlg.Combo_Longitude_Mode.currentText() == "Raw data")
        self.lon_step = dlg.Combo_Longitude_Resolution.currentText()

        if (self.time_raw != prev_time_raw) or (self.time_step != prev_time_step):
            self.refresh_time_combo()

        if self.alt_raw != prev_alt_raw:
            self.refresh_alt_combo()
            self.toggle_altitude_multi()

        if (self.lat_raw != prev_lat_raw) or (self.lat_step != prev_lat_step):
            self.refresh_lat_combo()

        if (self.lon_raw != prev_lon_raw) or (self.lon_step != prev_lon_step):
            self.refresh_lon_combo()

    def refresh_time_combo(self):
        times = self.ds.Time.values.astype(float)
        t_min = times.min()
        t_max = times.max()

        if self.time_raw:
            grid = times
        else:
            if self.time_step == "1 hour":
                step = 1
            elif self.time_step == "30 min":
                step = 0.5
            elif self.time_step == "15 min":
                step = 0.25
            else:
                step = 1.0

            extra = np.arange(step, t_min, step)
            main = np.arange(t_min, t_max + 1e-6, step)
            grid = np.concatenate([extra, main])

        labels = []

        for t in grid:
            h = int(t)
            m = int(round((t-h) * 60))

            if m == 60:
                t = t+1
                m = 0

            labels.append(f"{h:02d}:{m:02d}")

        self.Combo_Hora.clear()
        self.Combo_Hora.addItems(labels)

    def refresh_alt_combo(self): #Repoblate Combo_Altitud when alt_raw is true

        if not self.alt_raw:
            return

        alts = self.ds.altitude.values.astype(float)
        labels = []

        for a in alts:
            labels.append(f"{a:.4f}")

        self.Combo_Altitud.clear()
        self.Combo_Altitud.addItems(labels)

    def refresh_lat_combo(self):
        lats = self.ds.latitude.values.astype(float)
        lat_min = lats.min()
        lat_max = lats.max()

        if self.lat_raw:
            grid = lats
        else:
            if self.lat_step == "2":
                step = 2
            elif self.lat_step == "1":
                step = 1
            elif self.lat_step == "0.5":
                step = 0.5
            elif self.lat_step == "0.25":
                step = 0.25
            elif self.lat_step == "0.1":
                step = 0.1
            else:
                step = 1.0

            extra = np.arange(step, lat_min, step)
            main = np.arange(lat_min, lat_max + 1e-6, step)
            grid = np.concatenate([extra, main])

        labels = []
        for v in grid:
            labels.append(f"{v:.4f}")

        if not self.lat_raw:
            labels.reverse()

        self.Combo_Latitud_Min.clear()
        self.Combo_Latitud_Min.addItems(labels)
        self.Combo_Latitud_Max.clear()
        self.Combo_Latitud_Max.addItems(labels)

    def refresh_lon_combo(self):
        lons = self.ds.longitude.values.astype(float)
        lon_min = lons.min()
        lon_max = lons.max()

        if self.lon_raw:
            grid = lons
        else:
            if self.lon_step == "2":
                step = 2
            elif self.lon_step == "1":
                step = 1
            elif self.lon_step == "0.5":
                step = 0.5
            elif self.lon_step == "0.25":
                step = 0.25
            elif self.lon_step == "0.1":
                step = 0.1
            else:
                step = 1.0

            extra = np.arange(step, lon_min, step)
            main = np.arange(lon_min, lon_max + 1e-6, step)
            grid = np.concatenate([extra, main])

        labels = []
        for v in grid:
            labels.append(f"{v:.4f}")

        self.Combo_Longitud_Min.clear()
        self.Combo_Longitud_Min.addItems(labels)
        self.Combo_Longitud_Max.clear()
        self.Combo_Longitud_Max.addItems(labels)

    def cambio_epoca(self, epoca):
        #Handler for when the era combo changes: populate the file list
        carpeta = self.lista_carpetas.get(epoca)

        if not carpeta:
            return #Nothing to do if no valid folder

        prev_archivo = self.Combo_Archivo.currentText() #Stores file that was previously selected
        self.Combo_Archivo.clear()

        folder = os.path.join(self.ruta, carpeta)

        try:
            archivos = sorted(f for f in os.listdir(folder) if f.endswith("_me.nc") and "thermo" not in f.lower())
        except FileNotFoundError:
            QMessageBox.warning(self, "Error", "Folder not found")
            return

        self.Combo_Archivo.addItems(archivos)

        if prev_archivo in archivos:
            self.Combo_Archivo.setCurrentText(prev_archivo)
            self.cambio_archivo(prev_archivo)
        else:
            if len(archivos) > 0:
                self.Combo_Archivo.setCurrentIndex(0)
                self.cambio_archivo(self.Combo_Archivo.currentText())

    def cambio_archivo(self, archivo_nombre):
        if not archivo_nombre:
            return

        epoca_label = self.Combo_Epoca.currentText()
        carpeta = self.lista_carpetas.get(epoca_label)
        if not carpeta:
           return

        path = os.path.join(self.ruta, carpeta, archivo_nombre)
        try:
            ds_nuevo = xr.open_dataset(path, decode_times=False)
        except Exception as e:
            QMessageBox.critical(self, "Error al abrir NetCDF", str(e))
            return

        self.ds = ds_nuevo

        prev_vars = [item.data(Qt.UserRole) for item in self.Combo_Variable.selectedItems()] #We save already selected variables for its name in "crude"
        self.Combo_Variable.clear()

        for varname in self.ds.data_vars.keys():
            data_array = self.ds[varname]
            if("latitude" in data_array.dims) and ("longitude" in data_array.dims): #I just want to have variables that contain latitude and longitude dimensions. Otherwise, none of my interest
                if varname in self.variable_descriptions:
                    label = self.variable_descriptions[varname] # I assign a "human" name to thoses varnames (e.g. temp = "Surface Temparature (K)")
                    item = QtWidgets.QListWidgetItem(label)
                else:
                    item = QtWidgets.QListWidgetItem(f"ERROR: {varname}")
                    item.setForeGround(QColor("red"))

                item.setData(Qt.UserRole, varname)
                self.Combo_Variable.addItem(item)

        for i in range(self.Combo_Variable.count()):
            itm = self.Combo_Variable.item(i)
            if itm.data(Qt.UserRole) in prev_vars:
                itm.setSelected(True)

        prev_hora = self.Combo_Hora.currentText()
        self.refresh_time_combo()

        items = []
        for i in range(self.Combo_Hora.count()):
            items.append(self.Combo_Hora.itemText(i))

        if prev_hora in items:
            self.Combo_Hora.setCurrentText(prev_hora)
        elif self.Combo_Hora.count() > 0:
            self.Combo_Hora.setCurrentIndex(0)

        prev_alt_combo = self.Combo_Altitud.currentText()
        prev_alt_manual = self.Interpolate_Altitude.text()
        self.refresh_alt_combo()

        items_a = []

        for i in range(self.Combo_Altitud.count()):
            items_a.append(self.Combo_Altitud.itemText(i))

        if prev_alt_combo in items_a:
            self.Combo_Altitud.setCurrentText(prev_alt_combo)
        else:
            self.Combo_Altitud.setCurrentIndex(0)

        if not self.alt_raw:
            self.Interpolate_Altitude.setText(prev_alt_manual)
        else:
            self.Interpolate_Altitude.clear()

        self.toggle_altitude_multi()

        prev_lat_min = self.Combo_Latitud_Min.currentText()
        prev_lat_max = self.Combo_Latitud_Max.currentText()
        prev_lon_min = self.Combo_Longitud_Min.currentText()
        prev_lon_max = self.Combo_Longitud_Max.currentText()

        self.refresh_lat_combo()
        self.refresh_lon_combo()

        items_lat = []
        items_lon = []

        for i in range(self.Combo_Latitud_Min.count()):
            items_lat.append(self.Combo_Latitud_Min.itemText(i))

        if prev_lat_min in items_lat:
            self.Combo_Latitud_Min.setCurrentText(prev_lat_min)
        if prev_lat_max in items_lat:
            self.Combo_Latitud_Max.setCurrentText(prev_lat_max)

        for i in range(self.Combo_Longitud_Min.count()):
            items_lon.append(self.Combo_Longitud_Min.itemText(i))

        if prev_lon_min in items_lon:
            self.Combo_Longitud_Min.setCurrentText(prev_lon_min)
        if prev_lon_max in items_lon:
            self.Combo_Longitud_Max.setCurrentText(prev_lon_max)

    def toggle_altitude_multi(self):
        vars_marcadas = []
        for item in self.Combo_Variable.selectedItems():
            vars_marcadas.append(item.data(Qt.UserRole))

        if not vars_marcadas:
            self.Combo_Altitud.setEnabled(False)
            self.Combo_Altitud.setStyleSheet("QComboBox:disabled { background-color: red }")
            self.Combo_Altitud.setToolTip("Select one variable at least")
            self.Interpolate_Altitude.setEnabled(False)
            return

        for var in vars_marcadas:
            if var in self.ds.data_vars and "altitude" in self.ds[var].dims:
                if self.alt_raw:
                    self.Combo_Altitud.setEnabled(True)
                    self.Combo_Altitud.setStyleSheet("")
                    self.Combo_Altitud.setToolTip("")
                    self.Interpolate_Altitude.setEnabled(False)
                else:
                    self.Combo_Altitud.setEnabled(False)
                    self.Combo_Altitud.setStyleSheet("QComboBox:disabled { background-color: red }")
                    self.Combo_Altitud.setToolTip("Manual mode selected")
                    self.Interpolate_Altitude.setEnabled(True)
                return

        self.Combo_Altitud.setEnabled(False)
        self.Combo_Altitud.setStyleSheet("QComboBox:disabled { background-color: red }")
        self.Combo_Altitud.setToolTip("No variable selected contains 'altitude' dimension")
        self.Interpolate_Altitude.setEnabled(False)

    def toggle_map_latlon_mode(self, estado):

        checked = (estado != 0)

        combos = [self.Combo_Latitud_Min, self.Combo_Latitud_Max, self.Combo_Longitud_Min, self.Combo_Longitud_Max]

        if checked:
            for combo in combos:
                combo.setEnabled(False)
                combo.setStyleSheet("QComboBox { background-color: red; }")
                combo.setToolTip("Latitude/Longitude Selector is disabled when full map is selected")
        else:
            for combo in combos:
                combo.setEnabled(True)
                combo.setStyleSheet("")

    def reset_all(self):
        self.Combo_Epoca.setCurrentIndex(0)

        if self.Combo_Archivo.count() > 0:
            self.Combo_Archivo.setCurrentIndex(0)

        if self.Combo_Variable.count() > 0:
            for i in range(self.Combo_Variable.count()):
                self.Combo_Variable.item(i).setSelected(False)

        if self.Combo_Hora.count() > 0:
            self.Combo_Hora.setCurrentIndex(0)

        self.time_raw = True
        self.time_step = "1 hour"
        self.refresh_time_combo()

        self.alt_raw = True

        self.refresh_alt_combo()
        if self.Combo_Altitud.count() > 0:
            self.Combo_Altitud.setCurrentIndex(0)

        self.Interpolate_Altitude.clear()
        self.toggle_altitude_multi()

        self.lat_raw = True
        self.lon_raw = True

        self.lat_step = "2"
        self.lon_step = "2"

        self.refresh_lat_combo()
        self.refresh_lon_combo()

        if self.Combo_Latitud_Min.count() > 0:
            self.Combo_Latitud_Min.setCurrentIndex(0)
        if self.Combo_Latitud_Max.count() > 0:
            self.Combo_Latitud_Max.setCurrentIndex(0)
        if self.Combo_Longitud_Min.count() > 0:
            self.Combo_Longitud_Min.setCurrentIndex(0)
        if self.Combo_Longitud_Max.count() > 0:
            self.Combo_Longitud_Max.setCurrentIndex(0)

        if self.Check_Mapa.isChecked():
            self.Check_Mapa.setChecked(False)

    def visualizar_variable(self):
        #Main handler for visualizing the selected variable
        #Read numeric lat/lon from combos
        lat_min = float(self.Combo_Latitud_Min.currentText())
        lat_max = float(self.Combo_Latitud_Max.currentText())
        lon_min = float(self.Combo_Longitud_Min.currentText())
        lon_max = float(self.Combo_Longitud_Max.currentText())

        #Validate ranges if not showing full map
        if not self.Check_Mapa.isChecked():
            if lat_min >= lat_max:
                QMessageBox.warning(self, "Invalid latitude range",
                                    "Min latitude must be lower than max latitude")
                return
            if lon_min >= lon_max:
                QMessageBox.warning(self, "Invalid longitude range",
                                    "Min longitude must be lower than max longitude")
                return

        vars_sel = [item.data(Qt.UserRole) for item in self.Combo_Variable.selectedItems()]

        if not vars_sel:
            QMessageBox.warning(self, "No variables", "You must select at least one variable")
            return

        dlg = QProgressDialog("Generating raster layers...", None, 0, len(vars_sel), self)
        dlg.setWindowModality(Qt.WindowModal)
        dlg.setCancelButton(None)
        dlg.setMinimumDuration(0)
        dlg.setWindowTitle("Please, wait")
        dlg.show()

        try:
            for idx, varname in enumerate(vars_sel):
                da = self.ds[varname]

                if "Time" in da.dims:
                    if self.time_raw:
                        da = da.isel(Time = self.Combo_Hora.currentIndex())
                    else:
                        time_str = self.Combo_Hora.currentText()
                        h, m = map(int, time_str.split(":"))
                        user_time = h + m/60.0

                        t_min = float(self.ds.Time.values.min())
                        t_max = float(self.ds.Time.values.max())

                        if user_time >= t_min:
                            da = da.interp(Time = user_time, method = "linear") #normal interp [t_min, t_max]
                        else:
                            frac = user_time/t_min
                            v_low = da.sel(Time = t_max)
                            v_high = da.sel(Time = t_min)
                            da = v_low*(1-frac) + v_high*frac

                if "altitude" in da.dims:
                    if self.alt_raw:
                        da = da.isel(altitude = self.Combo_Altitud.currentIndex())
                    else:
                        text = self.Interpolate_Altitude.text()
                        if not text:
                            QMessageBox.warning(self, "Altitude", "Introduce altitude value in m")
                            return

                        #Forcing value to be in altitude limits coming from NetCDF data
                        if not text.isdigit():
                            QMessageBox.warning(self, "Altitude", "Do not introduce decimal values")
                            return

                        v = int(text)

                        if v < 5:
                            v = 5
                        elif v > 108000:
                            v = 108000

                        self.Interpolate_Altitude.setText(str(v))

                        user_alt_km = v / 1000.0
                        da = da.interp(altitude = user_alt_km, method = "linear")


                if not self.Check_Mapa.isChecked():
                    lat_vals = self.ds.latitude.values
                    lon_vals = self.ds.longitude.values

                    if self.lat_raw:
                        if lat_vals[0] < lat_vals[-1]:
                            lat_slice = slice(lat_min, lat_max)
                        else:
                            lat_slice = slice(lat_max, lat_min)

                        da = da.sel(latitude = lat_slice)
                    else:
                        new_lats = np.arange(lat_min, lat_max + 1e-6, float(self.lat_step))
                        da = da.interp(latitude = new_lats, method = "linear")

                    if self.lon_raw:
                        if lon_vals[0] < lon_vals[-1]:
                            lon_slice = slice(lon_min, lon_max)
                        else:
                            lon_slice = slice(lon_max, lon_min)

                        da = da.sel(longitude = lon_slice)
                    else:
                        new_lons = np.arange(lon_min, lon_max + 1e-6, float(self.lon_step))
                        da = da.interp(longitude = new_lons, method = "linear")

                lats = da.latitude.values
                lons = da.longitude.values
                array = da.values

                if array.size == 0:
                    QMessageBox.warning(self, "No data", f"Variable {self.variable_descriptions[varname]} has no data in the lat/lon cut.")
                    dlg.setValue(idx + 1)
                    QApplication.processEvents()
                    continue

                display_name = self.variable_descriptions[varname]
                self._mostrar_raster(array, lats, lons, varname, display_name)

                dlg.setValue(idx + 1)
                QApplication.processEvents()

            self.loadMolaBase()

        finally:
            dlg.close()

    def loadMolaBase(self):
        #Handler to load or reload the MOLA contour layer
        Processing.initialize()

        # Remove previous MOLA layer if presented by ID
        prev_id = getattr(self, 'mola_layer_id', None)
        if prev_id:
            lyr = QgsProject.instance().mapLayer(prev_id)
            if lyr:
                QgsProject.instance().removeMapLayer(prev_id)
            self.mola_layer_id = None
            self.mola_loaded = False

        #Path to original MOLA GeoTIFF
        plugin_dir = os.path.dirname(__file__)
        origen = os.path.join(plugin_dir, "mola32_isolines.tif")
        #Spatial crop if full map not checked on GUI
        if not self.Check_Mapa.isChecked():
            lon_min = float(self.Combo_Longitud_Min.currentText())
            lon_max = float(self.Combo_Longitud_Max.currentText())
            lat_min = float(self.Combo_Latitud_Min.currentText())
            lat_max = float(self.Combo_Latitud_Max.currentText())
            opts = gdal.TranslateOptions(format="GTiff",projWin=[lon_min, lat_max, lon_max, lat_min])
            tmp_tif = os.path.join(tempfile.gettempdir(), "mola_crop.tif")
            gdal.Translate(tmp_tif, origen, options=opts)
            raster_path = tmp_tif
        else:
            raster_path = origen

        # Downsample by factor 4 to speed up contour generation
        ds = gdal.Open(raster_path)
        gt = ds.GetGeoTransform()
        down_tif = os.path.join(tempfile.gettempdir(), "mola_down.tif")
        gdal.Warp(down_tif, ds,xRes=gt[1] * 4,yRes=abs(gt[5]) * 4,resampleAlg='bilinear')
        ds = None
        raster_path = down_tif

        # 3) Create unique shpapefile for contours
        shp_path = os.path.join(tempfile.gettempdir(), f"mola_contours_{uuid.uuid4().hex}.shp")
        # Clean lefotvers
        for ext in ("shp", "shx", "dbf", "prj"):
            try:
                os.remove(shp_path[:-3] + ext)
            except OSError:
                pass

        # Run GDAL contour algorithm to generate vector contours every 1000m
        params = {'INPUT': raster_path,'BAND': 1,'INTERVAL': 1000.0,'FIELD_NAME': 'ELEV','OUTPUT': shp_path}
        result = processing.run("gdal:contour", params)
        if 'OUTPUT' not in result or not result['OUTPUT']:
            QMessageBox.critical(self, "Error", "gdal:contour failed without exit.")
            return

        # Load resulting shapefile as a vector layer
        cont_layer = QgsVectorLayer(result['OUTPUT'], "MOLA Isolines", "ogr")
        if not cont_layer.isValid():
            QMessageBox.critical(self, "Error", "MOLA isolines could not be created.")
            return

        # Put image thickness up to 0.2mm
        sym = cont_layer.renderer().symbol()
        sym.setColor(QColor(0, 0, 0)) #Set line color to black
        sym.setWidth(0.2) #Set line width to 0.2mm
        cont_layer.triggerRepaint()

        #Add layer with default ordering so it appears on top
        root = QgsProject.instance().layerTreeRoot()
        QgsProject.instance().addMapLayer(cont_layer, addToLegend=False)
        root.insertLayer(0, cont_layer)

        #Save ID for future removal
        self.mola_layer_id = cont_layer.id()
        self.mola_loaded = True

    def _mostrar_raster(self, array, lat, lon, safe_name, layer_name):
        arr = np.asarray(array) #Internal method to display a numpy array as a QGIS raster layer

        #Check that data array is non-empty
        if arr.size == 0 or len(lat) == 0 or len(lon) == 0:
            QMessageBox.warning(self,"No data","Selected crop has no info")
            return

        # Ensure data to be displyed is 2D
        if arr.ndim != 2:
            QMessageBox.warning(self, "ERROR", "Raster is not a 2D File. Cannot be desplayed")
            return

        #Flip vertically for correct georeferencing
        arr = np.flipud(arr)

        #Create temporary GeoTIFF file
        temp_dir = tempfile.gettempdir()
        filename = f"{safe_name}_{uuid.uuid4().hex}.tif"
        path = os.path.join(temp_dir, filename)

        #Create geotransform parameters
        nrows, ncols = arr.shape
        xres = (lon[-1] - lon[0]) / ncols
        yres = (lat[-1] - lat[0]) / nrows

        drv = gdal.GetDriverByName("GTiff")
        ds = drv.Create(path, ncols, nrows, 1, gdal.GDT_Float32)
        ds.SetGeoTransform((lon[0], xres, 0, lat[-1], 0, -yres))
        srs = osr.SpatialReference()
        srs.ImportFromEPSG(4326)
        ds.SetProjection(srs.ExportToWkt())
        ds.GetRasterBand(1).WriteArray(arr)
        ds.FlushCache()
        ds = None

        #Load Geo TIFF as a QGIS Raster Layer
        layer = QgsRasterLayer(path, layer_name)
        if not layer.isValid():
            QMessageBox.critical(self, "Error", "No se pudo cargar el raster.")
            return

        #Apply pseudo-color renderer using turbo-ramp
        provider = layer.dataProvider()
        ramp = QgsStyle().defaultStyle().colorRamp('Turbo')
        renderer = QgsSingleBandPseudoColorRenderer(provider, 1)
        renderer.createShader(ramp,Qgis.ShaderInterpolationMethod.Linear,Qgis.ShaderClassificationMethod.Continuous,0)
        layer.setRenderer(renderer)
        layer.setOpacity(0.8) #Layer opacity up to 80%

        #Add layer to the project
        QgsProject.instance().addMapLayer(layer)
        layer.triggerRepaint()

        #Automatically applpy symology changes by simulating Apply click
        iface.showLayerProperties(layer, 'symbology')
        for w in QApplication.topLevelWidgets():
            if isinstance(w, QDialog) and w.windowTitle().startswith("Propiedades de capa"):
                w.close()
        iface.showLayerProperties(layer, 'symbology')
        for w in QApplication.topLevelWidgets():
            if isinstance(w, QDialog) and w.windowTitle().startswith("Propiedades de capa"):
                for bb in w.findChildren(QDialogButtonBox):
                    btn_apply = bb.button(QDialogButtonBox.Apply)
                    if btn_apply:
                        btn_apply.click()
                        w.close()
                break

    # PROFILE TOOL BEGINNING

    def open_interp_config_profile(self):
        prev_time_raw = self.time_raw_profile
        prev_time_step = self.time_step_profile
        prev_alt_raw = self.alt_raw_profile
        prev_lat_raw = self.lat_raw_profile
        prev_lat_step = self.lat_step_profile
        prev_lon_raw = self.lon_raw_profile
        prev_lon_step = self.lon_step_profile

        dlg = InterpConfigDialogProfile(parent=self)
        if dlg.exec_() != QtWidgets.QDialog.Accepted:
            return

        self.time_raw_profile  = (dlg.Combo_Time_Mode_Profile.currentText() == "Raw data")
        self.time_step_profile = dlg.Combo_Time_Resolution_Profile.currentText()

        self.alt_raw_profile = (dlg.Combo_Altitude_Mode_Profile.currentText() == "Raw data")

        self.lat_raw_profile  = (dlg.Combo_Latitude_Mode_Profile.currentText() == "Raw data")
        self.lat_step_profile = dlg.Combo_Latitude_Resolution_Profile.currentText()

        self.lon_raw_profile  = (dlg.Combo_Longitude_Mode_Profile.currentText() == "Raw data")
        self.lon_step_profile = dlg.Combo_Longitude_Resolution_Profile.currentText()

        if (self.time_raw_profile != prev_time_raw) or (self.time_step_profile != prev_time_step):
            self.refresh_time_combo_profile()

        if self.alt_raw_profile != prev_alt_raw:
            self.refresh_alt_combo_profile()

        if (self.lat_raw_profile != prev_lat_raw) or (self.lat_step_profile != prev_lat_step):
            self.refresh_lat_combo_profile()

        if (self.lon_raw_profile != prev_lon_raw) or (self.lon_step_profile != prev_lon_step):
            self.refresh_lon_combo_profile()

        self.on_profile_axes_changed()

    def refresh_time_combo_profile(self):
        times = self.ds.Time.values.astype(float)
        t_min = times.min()
        t_max = times.max()

        if self.time_raw_profile:
            grid = times
        else:
            if self.time_step_profile == "1 hour":
                step = 1
            elif self.time_step_profile == "30 min":
                step = 0.5
            elif self.time_step_profile == "15 min":
                step = 0.25
            else:
                step = 1.0

            extra = np.arange(step, t_min, step)
            main = np.arange(t_min, t_max + 1e-6, step)
            grid = np.concatenate([extra, main])

        labels = []

        for t in grid:
            h = int(t)
            m = int(round((t-h) * 60))

            if m == 60:
                t = t+1
                m = 0

            labels.append(f"{h:02d}:{m:02d}")

        self.Combo_Hora_Profile.clear()
        self.Combo_Hora_Profile.addItems(labels)

    def refresh_alt_combo_profile(self): #Repoblate Combo_Altitud when alt_raw is true

        if not self.alt_raw_profile:
            return

        alts = self.ds.altitude.values.astype(float)
        labels = []

        for a in alts:
            labels.append(f"{a:.4f}")

        self.Combo_Altitud_Profile.clear()
        self.Combo_Altitud_Profile.addItems(labels)

    def refresh_lat_combo_profile(self):
        lats = self.ds.latitude.values.astype(float)
        lat_min = lats.min()
        lat_max = lats.max()

        if self.lat_raw_profile:
            grid = lats
        else:
            if self.lat_step_profile == "2":
                step = 2
            elif self.lat_step_profile == "1":
                step = 1
            elif self.lat_step_profile == "0.5":
                step = 0.5
            elif self.lat_step_profile == "0.25":
                step = 0.25
            elif self.lat_step_profile == "0.1":
                step = 0.1
            else:
                step = 1.0

            extra = np.arange(step, lat_min, step)
            main = np.arange(lat_min, lat_max + 1e-6, step)
            grid = np.concatenate([extra, main])

        labels = []
        for v in grid:
            labels.append(f"{v:.4f}")

        if not self.lat_raw_profile:
            labels.reverse()

        self.Combo_Latitud_Profile.clear()
        self.Combo_Latitud_Profile.addItems(labels)

    def refresh_lon_combo_profile(self):
        lons = self.ds.longitude.values.astype(float)
        lon_min = lons.min()
        lon_max = lons.max()

        if self.lon_raw_profile:
            grid = lons
        else:
            if self.lon_step_profile == "2":
                step = 2
            elif self.lon_step_profile == "1":
                step = 1
            elif self.lon_step_profile == "0.5":
                step = 0.5
            elif self.lon_step_profile == "0.25":
                step = 0.25
            elif self.lon_step_profile == "0.1":
                step = 0.1
            else:
                step = 1.0

            extra = np.arange(step, lon_min, step)
            main = np.arange(lon_min, lon_max + 1e-6, step)
            grid = np.concatenate([extra, main])

        labels = []
        for v in grid:
            labels.append(f"{v:.4f}")

        self.Combo_Longitud_Profile.clear()
        self.Combo_Longitud_Profile.addItems(labels)

    def cambio_epoca_profile(self, epoca):
        carpeta = self.lista_carpetas.get(epoca)
        if carpeta is None:
            QMessageBox.warning(self, "Error", f"Escenario desconocido: {epoca}")
            return

        ruta_carpeta = os.path.join(self.ruta, carpeta)

        try:
            archivos = sorted(f for f in os.listdir(ruta_carpeta) if f.endswith("_me.nc") and "thermo" not in f.lower())
        except FileNotFoundError:
            QMessageBox.warning(self, "Error", f"Carpeta no encontrada:\n{ruta_carpeta}")
            archivos = []

        prev = self.Combo_Archivo_Profile.currentText()

        self.Combo_Archivo_Profile.clear()
        self.Combo_Archivo_Profile.addItems(archivos)

        if prev in archivos:
            self.Combo_Archivo_Profile.setCurrentText(prev)
        elif archivos:
            self.Combo_Archivo_Profile.setCurrentIndex(0)

        current = self.Combo_Archivo_Profile.currentText()
        if current:
            self.cambio_archivo_profile(current)

    def cambio_archivo_profile(self, archivo_nombre):
        if not archivo_nombre:
            return

        epoca_label = self.Combo_Epoca_Profile.currentText()
        carpeta = self.lista_carpetas.get(epoca_label)
        if not carpeta:
            return

        path = os.path.join(self.ruta, carpeta, archivo_nombre)
        try:
            ds_nuevo = xr.open_dataset(path, decode_times=False)
        except Exception as e:
            QMessageBox.critical(self, "Error al abrir NetCDF", str(e))
            return

        self.ds = ds_nuevo

        prev_vars = [item.data(Qt.UserRole) for item in self.Combo_Variable_Profile.selectedItems()] #We save already selected variables for its name in "crude"
        self.Combo_Variable_Profile.clear()

        for varname in self.ds.data_vars.keys():
            data_array = self.ds[varname]
            if("latitude" in data_array.dims) and ("longitude" in data_array.dims): #I just want to have variables that contain latitude and longitude dimensions. Otherwise, none of my interest
                if varname in self.variable_descriptions:
                    label = self.variable_descriptions[varname] # I assign a "human" name to thoses varnames (e.g. temp = "Surface Temparature (K)")
                    item = QtWidgets.QListWidgetItem(label)
                else:
                    item = QtWidgets.QListWidgetItem(f"ERROR: {varname}")
                    item.setForeGround(QColor("red"))

                item.setData(Qt.UserRole, varname)
                self.Combo_Variable_Profile.addItem(item)

        for i in range(self.Combo_Variable_Profile.count()):
            itm = self.Combo_Variable_Profile.item(i)
            if itm.data(Qt.UserRole) in prev_vars:
                itm.setSelected(True)

        prev_hora = self.Combo_Hora_Profile.currentText()
        self.refresh_time_combo_profile()

        hora_items = []
        for i in range(self.Combo_Hora_Profile.count()):
            hora_items.append(self.Combo_Hora_Profile.itemText(i))

        if prev_hora in hora_items:
            self.Combo_Hora_Profile.setCurrentText(prev_hora)
        elif self.Combo_Hora_Profile.count() > 0:
            self.Combo_Hora_Profile.setCurrentIndex(0)

        prev_alt = self.Combo_Altitud_Profile.currentText()
        prev_alt_manual = self.Interpolate_Altitude_Profile.text()

        self.refresh_alt_combo_profile()

        alt_items = []
        for i in range(self.Combo_Altitud_Profile.count()):
            alt_items.append(self.Combo_Altitud_Profile.itemText(i))

        if prev_alt in alt_items:
            self.Combo_Altitud_Profile.setCurrentText(prev_alt)
        elif self.Combo_Altitud_Profile.count() > 0:
            self.Combo_Altitud_Profile.setCurrentIndex(0)

        if not self.alt_raw_profile:
            self.Interpolate_Altitude_Profile.setText(prev_alt_manual)
        else:
            self.Interpolate_Altitude_Profile.clear()

        prev_lat = self.Combo_Latitud_Profile.currentText()

        self.refresh_lat_combo_profile()

        lat_items = []
        for i in range(self.Combo_Latitud_Profile.count()):
            lat_items.append(self.Combo_Latitud_Profile.itemText(i))

        if prev_lat in lat_items:
            self.Combo_Latitud_Profile.setCurrentText(prev_lat)
        elif self.Combo_Latitud_Profile.count() > 0:
            self.Combo_Latitud_Profile.setCurrentIndex(0)

        prev_lon = self.Combo_Longitud_Profile.currentText()

        self.refresh_lon_combo_profile()

        lon_items = []
        for i in range(self.Combo_Longitud_Profile.count()):
            lon_items.append(self.Combo_Longitud_Profile.itemText(i))

        if prev_lon in lon_items:
            self.Combo_Longitud_Profile.setCurrentText(prev_lon)
        elif self.Combo_Longitud_Profile.count() > 0:
            self.Combo_Longitud_Profile.setCurrentIndex(0)

        self.on_profile_axes_changed()

    def on_profile_axes_changed(self, idx=None):
        combo = self.sender()

        x = self.Combo_Profile_X.currentText()
        y = self.Combo_Profile_Y.currentText()

        if x == y and x != "N/A":
            QMessageBox.warning(self,"Profile","Axis Variable X cannot be the same as Axis Variable Y")
            combo.setCurrentIndex(0)
            return

        if x == "Local Time" or y == "Local Time":
            self.Combo_Hora_Profile.setEnabled(False)
            self.Combo_Hora_Profile.setStyleSheet("QComboBox{background:red}")
            self.Combo_Hora_Profile.setToolTip("Local Time locked as axis")
        else:
            self.Combo_Hora_Profile.setEnabled(True)
            self.Combo_Hora_Profile.setStyleSheet("")
            self.Combo_Hora_Profile.setToolTip("")

        sel = self.Combo_Variable_Profile.selectedItems()

        if x == "Altitude" or y == "Altitude":
            self.Combo_Altitud_Profile.setEnabled(False)
            self.Combo_Altitud_Profile.setStyleSheet("QComboBox{background:red}")
            self.Combo_Altitud_Profile.setToolTip("Altitude locked as axis")
            self.Interpolate_Altitude_Profile.setEnabled(False)

        elif sel and 'altitude' not in self.ds[sel[0].data(Qt.UserRole)].dims:
            self.Interpolate_Altitude_Profile.setEnabled(False)
            self.Combo_Altitud_Profile.setEnabled(False)
            self.Combo_Altitud_Profile.setStyleSheet("QComboBox{background:red}")
            self.Combo_Altitud_Profile.setToolTip("Selected variable has no 'altitude' dimension")

        else:
            if self.alt_raw_profile:
                self.Combo_Altitud_Profile.setEnabled(True)
                self.Combo_Altitud_Profile.setStyleSheet("")
                self.Combo_Altitud_Profile.setToolTip("")
                self.Interpolate_Altitude_Profile.setEnabled(False)
            else:
                self.Combo_Altitud_Profile.setEnabled(False)
                self.Combo_Altitud_Profile.setStyleSheet("QComboBox { background:red }")
                self.Combo_Altitud_Profile.setToolTip("Manual mode selected")
                self.Interpolate_Altitude_Profile.setEnabled(True)

        if x == "Latitude" or y == "Latitude":
            self.Combo_Latitud_Profile.setEnabled(False)
            self.Combo_Latitud_Profile.setStyleSheet("QComboBox{background:red}")
            self.Combo_Latitud_Profile.setToolTip("Latitude locked as axis")
        else:
            self.Combo_Latitud_Profile.setEnabled(True)
            self.Combo_Latitud_Profile.setStyleSheet("")
            self.Combo_Latitud_Profile.setToolTip("")

        if x == "Longitude" or y == "Longitude":
            self.Combo_Longitud_Profile.setEnabled(False)
            self.Combo_Longitud_Profile.setStyleSheet("QComboBox{background:red}")
            self.Combo_Longitud_Profile.setToolTip("Longitude locked as axis")
        else:
            self.Combo_Longitud_Profile.setEnabled(True)
            self.Combo_Longitud_Profile.setStyleSheet("")
            self.Combo_Longitud_Profile.setToolTip("")

        self.Combo_Variable_Profile.setEnabled(True)
        self.Combo_Variable_Profile.setStyleSheet("")
        self.Combo_Variable_Profile.setToolTip("")

        if x != "N/A" and y != "N/A" and sel:
            self.Push_Visualizar_Profile.setEnabled(True)
        else:
            self.Push_Visualizar_Profile.setEnabled(False)

    def reset_all_profile(self):
        self.Combo_Epoca_Profile.setCurrentIndex(0)
        if self.Combo_Archivo_Profile.count() > 0:
            self.Combo_Archivo_Profile.setCurrentIndex(0)

        self.time_raw_profile = True
        self.time_step_profile = "1 hour"
        self.refresh_time_combo_profile()

        self.alt_raw_profile = True
        self.refresh_alt_combo_profile()

        self.lat_raw_profile = True
        self.lat_step_profile = "2"
        self.refresh_lat_combo_profile()

        self.lon_raw_profile = True
        self.lon_step_profile = "2"
        self.refresh_lon_combo_profile()

        self.Combo_Profile_X.setCurrentIndex(0)
        self.Combo_Profile_Y.setCurrentIndex(0)

        for i in range(self.Combo_Variable_Profile.count()):
            self.Combo_Variable_Profile.item(i).setSelected(False)

        if self.Combo_Hora_Profile.count() > 0:
            self.Combo_Hora_Profile.setCurrentIndex(0)

        if self.Combo_Altitud_Profile.count() > 0:
            self.Combo_Altitud_Profile.setCurrentIndex(0)

        if self.Combo_Latitud_Profile.count() > 0:
            self.Combo_Latitud_Profile.setCurrentIndex(0)

        if self.Combo_Longitud_Profile.count() > 0:
            self.Combo_Longitud_Profile.setCurrentIndex(0)

        self.on_profile_axes_changed()

    def visualize_variable_profile(self):

        x_axis = self.Combo_Profile_X.currentText()
        y_axis = self.Combo_Profile_Y.currentText()

        items = self.Combo_Variable_Profile.selectedItems()

        if not items:
            QMessageBox.warning(self, "Profile", "Select a variable to plot")
            return

        var_name = items[0].data(Qt.UserRole)
        desc = self.variable_descriptions.get(var_name, var_name)

        da = self.ds[var_name]

        fixed_info = {} #Dictionary for fixed dimensions

        if x_axis != 'Local Time' and y_axis != 'Local Time':
            txt_time = self.Combo_Hora_Profile.currentText()
            disp_time = f"{txt_time} h"

            if ':' in txt_time:
                h,m = map(int, txt_time.split(':'))
                val_time = h + m/60.0
            else:
                val_time = float(txt_time)

            fixed_info['Local Time'] = disp_time #Saves in fixed_info dictionary that Local Time has value disp time
            da = da.sel(Time = val_time)

        if x_axis != 'Altitude' and y_axis != 'Altitude':
            if 'altitude' in da.dims or 'altitude' in da.coords:
                txt_alt = self.Combo_Altitud_Profile.currentText()
                disp_alt = f"{txt_alt} km"
                val_alt = float(txt_alt)
                fixed_info['Altitude'] = disp_alt
                da = da.sel(altitude = val_alt, method = 'nearest')

        if x_axis != 'Latitude' and y_axis != 'Latitude':
            txt_lat = self.Combo_Latitud_Profile.currentText()
            disp_lat = f"{txt_lat}°"
            val_lat = float(txt_lat)
            fixed_info['Latitude'] = disp_lat
            da = da.sel(latitude=val_lat)

        if x_axis != 'Longitude' and y_axis != 'Longitude':
            txt_lon = self.Combo_Longitud_Profile.currentText()
            disp_lon = f"{txt_lon}°"
            val_lon = float(txt_lon)
            fixed_info['Longitude'] = disp_lon
            da = da.sel(longitude=val_lon)

        dims_left = list(da.dims) #Free dimensions after fixing previous ones
        fig, ax = plt.subplots() #Preparing the plot

        if 'Variable' in (x_axis, y_axis):
            if len(dims_left) != 1:
                QMessageBox.warning(self, "Profile", "For 1D profile you must leave only one free dimension")
                return

            d = dims_left[0]
            coords = da.coords[d].values
            values = da.values

            if x_axis == 'Variable':
                x_vals, y_vals = values, coords
                xlabel, ylabel = desc, d
            else:
                x_vals, y_vals = coords, values
                xlabel, ylabel = d, desc

            ax.plot(x_vals, y_vals, '-o')

        else:
            if len(dims_left) != 2:
                QMessageBox.warning(self, "Profile", "For 2D profile you must leave two free dimension")
                return

            map_gui_to_dim = {'Local Time': 'Time','Altitude': 'altitude','Latitude': 'latitude','Longitude': 'longitude'}

            x_dim = map_gui_to_dim[x_axis]
            y_dim = map_gui_to_dim[y_axis]
            arr = da.transpose(y_dim, x_dim)
            xs = arr.coords[x_dim].values
            ys = arr.coords[y_dim].values
            vals = arr.values

            mesh = ax.pcolormesh(xs, ys, vals, shading='auto', cmap='inferno', vmin=vals.min(), vmax=vals.max()); fig.colorbar(mesh, ax=ax).set_label(desc)
            cbar = fig.colorbar(mesh, ax=ax)
            cbar.set_label(desc)
            xlabel, ylabel = x_axis, y_axis

        unit_suffix = {
            'Time': ' (h)', 'altitude': ' (km)',
            'latitude': ' (º)', 'longitude': ' (º)',
            'Local Time': ' (h)', 'Altitude': ' (km)',
            'Latitude': ' (º)', 'Longitude': ' (º)',
        }

        xlabel_full = xlabel + unit_suffix.get(xlabel, "")
        ylabel_full = ylabel + unit_suffix.get(ylabel, "")

        epoca = self.Combo_Epoca_Profile.currentText()
        archivo = self.Combo_Archivo_Profile.currentText()
        fixed_parts = [f"{k}: {v}" for k, v in fixed_info.items()]
        fixed_str = " | ".join(fixed_parts)
        ax.set_title(f"{epoca} | {archivo}\n"f"{fixed_str}\n")

        ax.set_xlabel(xlabel_full)
        ax.set_ylabel(ylabel_full)
        ax.grid(True, linestyle=':')
        plt.tight_layout()
        plt.show()

    def closeEvent(self, event):
        #Emit signal and accept close event when plugin is closed
        self.closingPlugin.emit()
        event.accept()